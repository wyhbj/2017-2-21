粗略版的面向对象  ->  构造函数 -> 工厂方式
	function Teacher(name,age){
		var obj = {}; //原材料
		obj.name = name;
		obj.age = age; //加工
		obj.say = function(){
			alert(this.name);
		}
		
		return obj; //出厂
	}
	
	var t1 = new Teacher('nizp',18);
	//console.log(t1);
	t1.say();
	属性：名字前是有主的
	变量:变量名前面没有主的
	非空对象上才能加属性或者方法。
	函数:名前面没有主的
	方法:名字前是有主的
	var arr = [1,2,3];
	function fn(){ //函数
		alert(this);
	}
	
	arr.fn = function(){ //方法
		alert(this);
	}
	
	arr.fn();
	fn();
	new 为运算符
	专门用来运算函数的(相当于把一个函数调用了)
	new 函数之后的返回值就变成了对象。
	1.相当于在函数内部创建了一个对象，并且返回这个对象
	2.如果没有return默认返回这个对象，如果有return，后面跟着是个对象，那么函数名+() = return 后面的对象，如果不是对象，那么依然返回对象。
	3.里面的变量就要变成对象的属性，函数就要改成这个对象上的方法。
	function Teacher(name,age){
		//var obj = {}; //原材料
		this.name = name;
		this.age = age; //加工
		this.say = function(){
			alert(this.name);
		}
		//return {'job':'前端'};
		return '123456';
		//return obj; //出厂
	}
	
	var t1 = new Teacher('nizp',18);//实例化对象（过程）
	console.log(t1);
	//t1.say();
	new运算前和运算后 
	函数名后的()是用来传参用的。
	如果不传参()可以省略。
	类:
		-> 函数 - 这个函数就返回一个对象 -> 构造函数
		
	new：
		-> return后面写对象，返回值就是写的这个对象
			 return后面跟的不是对象，返回值就是构造函数这个对象。
			 尽量把变量变成属性，把函数变成方法。
			 在不传参的情况下，可以不用加括号 new + 函数名即可调用这个函数。
			 构造函数内的this指向了这个构造函数（就是这个对象）。
		
	没有new
		-> return后面写什么，返回值就是什么。
			必须函数名 + 括号才能调用这个函数
			   
	行业的潜规则：
		如果某个函数为构造函数，那么函数名的首字母要大写。
	有性能问题 
		原型：prototype 能够解决性能问题。(*函数*身上才有的)
		***函数.prototype 值为 对象 
		给构造函数加上了一个class
		id
		***原型链:对象身上有原型链,但是没有原型。
		***原型:函数身上既有原型也有原型链。
		原型链是什么：
			实例化对象与构造函数下原型的桥梁。
		1.如果从对象身上去查找某个方法，如果没有，还会继续查找
		2.还会通过对象身上的原型链去查找
		3.构造函数的原型
	function Teacher(name,age,job){
		this.myName = name;
		this.myAge = age;
		this.myJob = job;
//		this.say = function(){
//			alert(this.myJob);
//		}
	}
	
	Teacher.prototype.say = function(){
		alert(this.myJob);
	};
	
	var t = new Teacher('nizp',38,'前端111111');
	var t2 = new Teacher('chenbin',3,'前端222222');
	
//	t.say = function(){
//		alert(11111);
//	}

	console.log(t);
	
//	console.log(t.__proto__ == Teacher.prototype);
	
	t.say();
//	t2.say();

	实例化对象的链儿 ==  构造函数的原型
	t.say  ->  t.__proto__  -> Teacher.prototype
	Teacher.prototype = {} -> Teacher.prototype.__proto__
	Object.prototype.say
	对象自身的优先级最高   > 这个对象的构造函数的原型 > Object.prototype
函数的原型，只给函数的实例化对象使用。 
	1.从对象身上找
		对象身上有没有  （有就找到了）没有继续找
		对象身上的原型链找 -> 等同于找这个对象的构造函数的原型 （有就找到了）没有继续找
		构造函数原型下的原型链 -> Object.原型（有就找到了，没有就结束）
	2.从函数身上找
		如果函数自身没有 （有就找到了）没有继续找
		找函数的原型链（函数的原型，只给函数的实例化对象使用）
		Function.prototype  （有就找到了）没有继续找
		Object.原型（有就找到了，没有就结束）